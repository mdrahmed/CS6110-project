/***
 ***  generated by CSeq [ 0000 / 0000 ] 2023-04-18 00:34:19
 ***
 ***                      412D 2020.03.24 core/merger
 ***                      DA01 2020.03.25 core/module
 ***                      F30A 2020.03.28 core/parser
 ***                      CEA9 2020.04.14 core/utils
 ***
 ***  params:
 ***    -i ../CS6110-project/wrapper.c
 ***
 ***  modules:
 ***    7C56 workarounds ()
 ***    AF6B functiontracker ()
 ***    49AF preinstrumenter (error-label)
 ***    0652 constants (deep-propagation)
 ***    6C2E spinlock ()
 ***    4FEF switchtransformer ()
 ***    43C1 dowhileconverter ()
 ***    85D2 conditionextractor ()
 ***    7ED7 varnames ()
 ***    7D83 functionpointer (fptr)
 ***    D804 preinliner ()
 ***    0A50 inliner (atomic-parameters simplify-args)
 ***    9CBA unroller (unwind unwind-while unwind-for unwind-for-max softunwindbound varnamesmap varscopesmap extra-tracking)
 ***    FD8E duplicator ()
 ***    8CB9 condwaitconverter ()
 ***    94BC lazyseq (rounds contexts threads schedule deadlock norobin preanalysis nondet-condvar-wakeups)
 ***    540D instrumenter (backend bitwidth header well-nested-locks emptystructs)
 ***    979F mapper (backend contexts unwind cores no-simplify reuse-dimacs)
 ***    F10A feeder (backend time llvm depth slevel no-simplify unwind contexts unwind 32 show-backend-output extrargs from to)
 ***    461B cex (backend cex threadnamesmap threadindexes threadindextoname varnamesmap coordstofunctions sv-comp witness entry threadsizes threadendlines loopheads)
 ***
 ***/
#define __cs_MUTEX_INITIALIZER -1
#define __cs_COND_INITIALIZER -1
#define __cs_RWLOCK_INITIALIZER -1
#define __cs_BARRIER_SERIAL_THREAD 0
#define __cs_CANCEL_ASYNCHRONOUS 0
#define __cs_CANCEL_ENABLE 0
#define __cs_CANCEL_DEFERRED 0
#define __cs_CANCEL_DISABLE 0
#define __cs_CANCELED 0
#define __cs_CREATE_DETACHED 0
#define __cs_CREATE_JOINABLE 0
#define __cs_EXPLICIT_SCHED 0
#define __cs_INHERIT_SCHED 0
#define __cs_MUTEX_DEFAULT 0
#define __cs_MUTEX_ERRORCHECK 0
#define __cs_MUTEX_NORMAL 0
#define __cs_MUTEX_RECURSIVE 0
#define __cs_MUTEX_ROBUST 0
#define __cs_MUTEX_STALLED 0
#define __cs_ONCE_INIT 0
#define __cs_PRIO_INHERIT 0
#define __cs_PRIO_NONE 0
#define __cs_PRIO_PROTECT 0
#define __cs_PROCESS_SHARED 0
#define __cs_PROCESS_PRIVATE 0
#define __cs_SCOPE_PROCESS 0
#define __cs_SCOPE_SYSTEM 0
int __VERIFIER_nondet_int();
int nondet_int();
unsigned int __VERIFIER_nondet_uint();
unsigned int nondet_uint();
_Bool __VERIFIER_nondet_bool();
_Bool nondet_bool();
char __VERIFIER_nondet_char();
char nondet_char();
unsigned char __VERIFIER_nondet_uchar();
unsigned char nondet_uchar();
//#include <stdio.h>
//#include <stdlib.h>
#define THREADS 5
#define ROUNDS 1
#define STOP_VOID(A) return;
#define STOP_NONVOID(A) return 0;
#define IF(T,A,B) if ((__cs_pc[T] > A)  |  (A >= __cs_pc_cs[T])) goto B;
#ifndef NULL
#define NULL 0
#endif
                         
                         unsigned __CPROVER_bitvector[1] __cs_active_thread[THREADS + 1] = {1};
                         
                         unsigned __CPROVER_bitvector[3] __cs_pc[THREADS + 1];
                         
                         unsigned __CPROVER_bitvector[4] __cs_pc_cs[THREADS + 1];
                         
                         unsigned __CPROVER_bitvector[3] __cs_thread_index;
                         
                         unsigned __CPROVER_bitvector[3] __cs_last_thread;
                         
                         unsigned __CPROVER_bitvector[3] __cs_thread_lines[] = {7, 6, 2, 4, 5, 4};
                         
                         void __cs_init_scalar(void *__cs_var, unsigned int __cs_size)
                         {
                                   
                                   if (__cs_size == (sizeof(int)))
                                             
                                   * ((int *) __cs_var) = (nondet_int());
                                   else
                         
                                             {
                                             
                                             __cs_var = (malloc(__cs_size));
                                   }
                         
                         }
                         
                         
                         void __CSEQ_message(char *__cs_message)
                         {
                                   ;
                         }
                         
                         
                         typedef int cspthread_t;
                         
                         void *__cs_threadargs[THREADS + 1];
                         
                         typedef int cspthread_key_t;
                         
                         cspthread_key_t __cs_keys[1][THREADS + 2];
                         
                         void (*__cs_key_destructor[1])(void *);
                         
                         int pthread_create_2(cspthread_t *__cs_new_thread_id, void *__cs_attr, void *(*__cs_func)(void *), void *__cs_arg, int __cs_threadID)
                         {
                                   
                                   if (__cs_threadID > THREADS)
                                             return (0);
                         
                                   
                                   * __cs_new_thread_id = (__cs_threadID);
                                   
                                   __cs_active_thread[__cs_threadID] = (1);
                                   
                                   __cs_threadargs[__cs_threadID] = (__cs_arg);
                                   
                                   __CSEQ_message("thread spawned");
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_join(cspthread_t __cs_id, void **__cs_value_ptr)
                         {
                                   
                                   __CPROVER_assume(__cs_pc[__cs_id] == __cs_thread_lines[__cs_id]);
                                   
                                   return (0);
                         }
                         
                         
                         void pthread_exit(void *__cs_value_ptr)
                         {
                                   
                                   if ((__cs_key_destructor[0] != 0) && (__cs_keys[0][__cs_thread_index + 1] != 0))
                                   {
                                             
                                             __cs_key_destructor[0]((void *) __cs_keys[0][__cs_thread_index + 1]);
                                   }
                         
                         }
                         
                         
                         int pthread_self(void)
                         {
                                   return (__cs_thread_index + 1);
                         }
                         
                         
                         typedef int cspthread_mutex_t;
                         
                         typedef int cspthread_mutexattr_t;
                         
                         int pthread_mutex_init(cspthread_mutex_t *__cs_m, cspthread_mutexattr_t *__cs_val)
                         {
                                   
                                   * __cs_m = (- 1);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_mutex_destroy(cspthread_mutex_t *__cs_mutex_to_destroy)
                         {
                                   
                                   * __cs_mutex_to_destroy = (- 2);
                                   
                                   __CSEQ_message("lock destroyed");
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_mutex_lock(cspthread_mutex_t *__cs_mutex_to_lock)
                         {
                                   
                                   __CPROVER_assume((* __cs_mutex_to_lock) == (- 1));
                                   
                                   * __cs_mutex_to_lock = (__cs_thread_index + 1);
                                   
                                   __CSEQ_message("lock acquired");
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_mutex_unlock(cspthread_mutex_t *__cs_mutex_to_unlock)
                         {
                                   
                                   __CPROVER_assume((* __cs_mutex_to_unlock) == (__cs_thread_index + 1));
                                   
                                   * __cs_mutex_to_unlock = (- 1);
                                   
                                   __CSEQ_message("lock released");
                                   
                                   return (0);
                         }
                         
                         
                         typedef int cspthread_cond_t;
                         
                         typedef int cspthread_condattr_t;
                         
                         int pthread_cond_init(cspthread_cond_t *__cs_cond_to_init, cspthread_condattr_t *__cs_attr)
                         {
                                   
                                   * __cs_cond_to_init = (- 1);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_cond_destroy(cspthread_cond_t *__cs_cond_to_destroy)
                         {
                                   
                                   * __cs_cond_to_destroy = (- 2);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_cond_wait_1(cspthread_cond_t *__cs_cond_to_wait_for, cspthread_mutex_t *__cs_m)
                         {
                                   
                                   pthread_mutex_unlock(__cs_m);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_cond_wait_2(cspthread_cond_t *__cs_cond_to_wait_for, cspthread_mutex_t *__cs_m)
                         {
                                   
                                   __CPROVER_assume((* __cs_cond_to_wait_for) == 1);
                                   
                                   pthread_mutex_lock(__cs_m);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_cond_signal(cspthread_cond_t *__cs_cond_to_signal)
                         {
                                   
                                   * __cs_cond_to_signal = (1);
                                   
                                   __CSEQ_message("conditional variable signal");
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_cond_broadcast(cspthread_cond_t *__cs_cond_to_broadcast)
                         {
                                   
                                   * __cs_cond_to_broadcast = (1);
                                   
                                   __CSEQ_message("conditional variable broadcast");
                                   
                                   return (0);
                         }
                         
                         
                         typedef struct cspthread_barrier_t
                         {
                                   
                                   unsigned int init;
                                   
                                   unsigned int current;
                         } cspthread_barrier_t;
                         
                         typedef int cspthread_barrierattr_t;
                         
                         int pthread_barrier_init(cspthread_barrier_t *__cs_barrier_to_init, cspthread_barrierattr_t *__cs_attr, unsigned int count)
                         {
                                   
                                   __cs_barrier_to_init->current = (count);
                                   
                                   __cs_barrier_to_init->init = (count);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_barrier_destroy(cspthread_barrier_t *__cs_barrier_to_destroy)
                         {
                                   
                                   __cs_barrier_to_destroy->init = (- 1);
                                   
                                   __cs_barrier_to_destroy->current = (- 1);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_barrier_wait_1(cspthread_barrier_t *__cs_barrier_to_wait)
                         {
                                   
                                   __cs_barrier_to_wait->current--;
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_barrier_wait_2(cspthread_barrier_t *__cs_barrier_to_wait)
                         {
                                   
                                   __CPROVER_assume(__cs_barrier_to_wait->current == 0);
                                   
                                   __cs_barrier_to_wait->current = (__cs_barrier_to_wait->init);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_key_create(cspthread_key_t *key, void (*destructor)(void *))
                         {
                                   
                                   static int currentkey = (0);
                                   
                                   __cs_key_destructor[0] = (destructor);
                                   
                                   * key = (currentkey++);
                                   
                                   return (0);
                         }
                         
                         
                         int pthread_setspecific(cspthread_key_t key, void *value)
                         {
                                   
                                   __cs_keys[key][__cs_thread_index + 1] = ((cspthread_key_t) value);
                                   
                                   return (0);
                         }
                         
                         
                         void *pthread_getspecific(cspthread_key_t key)
                         {
                                   
                                   return ((void *) __cs_keys[key][__cs_thread_index + 1]);
                         }
                         
                         
                         void __CSEQ_noop(void)
                         {
                         }
                         
                         
                         
                         typedef time_t mqtt_pal_time_t;
                         
                         typedef cspthread_mutex_t mqtt_pal_mutex_t;
                         
                         typedef int mqtt_pal_socket_handle;
                         
                         ssize_t mqtt_pal_sendall(mqtt_pal_socket_handle fd, void *buf, size_t len, int flags);
                         
                         ssize_t mqtt_pal_recvall(mqtt_pal_socket_handle fd, void *buf, size_t bufsz, int flags);
                         
                         enum MQTTControlPacketType {MQTT_CONTROL_CONNECT = 
                         1u, MQTT_CONTROL_CONNACK = 
                         2u, MQTT_CONTROL_PUBLISH = 
                         3u, MQTT_CONTROL_PUBACK = 
                         4u, MQTT_CONTROL_PUBREC = 
                         5u, MQTT_CONTROL_PUBREL = 
                         6u, MQTT_CONTROL_PUBCOMP = 
                         7u, MQTT_CONTROL_SUBSCRIBE = 
                         8u, MQTT_CONTROL_SUBACK = 
                         9u, MQTT_CONTROL_UNSUBSCRIBE = 
                         10u, MQTT_CONTROL_UNSUBACK = 
                         11u, MQTT_CONTROL_PINGREQ = 
                         12u, MQTT_CONTROL_PINGRESP = 
                         13u, MQTT_CONTROL_DISCONNECT = 
                         14u};
                         
                         struct mqtt_fixed_header
                         {
                                   
                                   enum MQTTControlPacketType control_type;
                                   
                                   uint32_t control_flags : 4;
                                   
                                   uint32_t remaining_length;
                         };
                         
                         enum MQTTErrors {MQTT_ERROR_UNKNOWN = 
                         INT_MIN, MQTT_ERROR_NULLPTR, MQTT_ERROR_CONTROL_FORBIDDEN_TYPE, MQTT_ERROR_CONTROL_INVALID_FLAGS, MQTT_ERROR_CONTROL_WRONG_TYPE, MQTT_ERROR_CONNECT_CLIENT_ID_REFUSED, MQTT_ERROR_CONNECT_NULL_WILL_MESSAGE, MQTT_ERROR_CONNECT_FORBIDDEN_WILL_QOS, MQTT_ERROR_CONNACK_FORBIDDEN_FLAGS, MQTT_ERROR_CONNACK_FORBIDDEN_CODE, MQTT_ERROR_PUBLISH_FORBIDDEN_QOS, MQTT_ERROR_SUBSCRIBE_TOO_MANY_TOPICS, MQTT_ERROR_MALFORMED_RESPONSE, MQTT_ERROR_UNSUBSCRIBE_TOO_MANY_TOPICS, MQTT_ERROR_RESPONSE_INVALID_CONTROL_TYPE, MQTT_ERROR_CONNECT_NOT_CALLED, MQTT_ERROR_SEND_BUFFER_IS_FULL, MQTT_ERROR_SOCKET_ERROR, MQTT_ERROR_MALFORMED_REQUEST, MQTT_ERROR_RECV_BUFFER_TOO_SMALL, MQTT_ERROR_ACK_OF_UNKNOWN, MQTT_ERROR_NOT_IMPLEMENTED, MQTT_ERROR_CONNECTION_REFUSED, MQTT_ERROR_SUBSCRIBE_FAILED, MQTT_ERROR_CONNECTION_CLOSED, MQTT_ERROR_INITIAL_RECONNECT, MQTT_ERROR_INVALID_REMAINING_LENGTH, MQTT_ERROR_CLEAN_SESSION_IS_REQUIRED, MQTT_ERROR_RECONNECT_FAILED, MQTT_ERROR_RECONNECTING, MQTT_OK = 
                         1};
                         
                         char *mqtt_error_str(enum MQTTErrors error);
                         
                         ssize_t __mqtt_pack_uint16(uint8_t *buf, uint16_t integer);
                         
                         uint16_t __mqtt_unpack_uint16(uint8_t *buf);
                         
                         ssize_t __mqtt_pack_str(uint8_t *buf, char *str);
                         
                         enum MQTTConnackReturnCode {MQTT_CONNACK_ACCEPTED = 
                         0u, MQTT_CONNACK_REFUSED_PROTOCOL_VERSION = 
                         1u, MQTT_CONNACK_REFUSED_IDENTIFIER_REJECTED = 
                         2u, MQTT_CONNACK_REFUSED_SERVER_UNAVAILABLE = 
                         3u, MQTT_CONNACK_REFUSED_BAD_USER_NAME_OR_PASSWORD = 
                         4u, MQTT_CONNACK_REFUSED_NOT_AUTHORIZED = 
                         5u};
                         
                         struct mqtt_response_connack
                         {
                                   
                                   uint8_t session_present_flag;
                                   
                                   enum MQTTConnackReturnCode return_code;
                         };
                         
                         struct mqtt_response_publish
                         {
                                   
                                   uint8_t dup_flag;
                                   
                                   uint8_t qos_level;
                                   
                                   uint8_t retain_flag;
                                   
                                   uint16_t topic_name_size;
                                   
                                   void *topic_name;
                                   
                                   uint16_t packet_id;
                                   
                                   void *application_message;
                                   
                                   size_t application_message_size;
                         };
                         
                         struct mqtt_response_puback
                         {
                                   
                                   uint16_t packet_id;
                         };
                         
                         struct mqtt_response_pubrec
                         {
                                   
                                   uint16_t packet_id;
                         };
                         
                         struct mqtt_response_pubrel
                         {
                                   
                                   uint16_t packet_id;
                         };
                         
                         struct mqtt_response_pubcomp
                         {
                                   
                                   uint16_t packet_id;
                         };
                         
                         enum MQTTSubackReturnCodes {MQTT_SUBACK_SUCCESS_MAX_QOS_0 = 
                         0u, MQTT_SUBACK_SUCCESS_MAX_QOS_1 = 
                         1u, MQTT_SUBACK_SUCCESS_MAX_QOS_2 = 
                         2u, MQTT_SUBACK_FAILURE = 
                         128u};
                         
                         struct mqtt_response_suback
                         {
                                   
                                   uint16_t packet_id;
                                   
                                   uint8_t *return_codes;
                                   
                                   size_t num_return_codes;
                         };
                         
                         struct mqtt_response_unsuback
                         {
                                   
                                   uint16_t packet_id;
                         };
                         
                         struct mqtt_response_pingresp
                         {
                                   
                                   int dummy;
                         };
                         
                         struct mqtt_response
                         {
                                   
                                   struct mqtt_fixed_header fixed_header;
                                   
                                   
                                   struct anonstruct_0
                                   {
                                             
                                             struct mqtt_response_connack connack;
                                             
                                             struct mqtt_response_publish publish;
                                             
                                             struct mqtt_response_puback puback;
                                             
                                             struct mqtt_response_pubrec pubrec;
                                             
                                             struct mqtt_response_pubrel pubrel;
                                             
                                             struct mqtt_response_pubcomp pubcomp;
                                             
                                             struct mqtt_response_suback suback;
                                             
                                             struct mqtt_response_unsuback unsuback;
                                             
                                             struct mqtt_response_pingresp pingresp;
                                   } decoded;
                         };
                         
                         ssize_t mqtt_unpack_fixed_header(struct mqtt_response *response, uint8_t *buf, size_t bufsz);
                         
                         ssize_t mqtt_unpack_connack_response(struct mqtt_response *mqtt_response, uint8_t *buf);
                         
                         ssize_t mqtt_unpack_publish_response(struct mqtt_response *mqtt_response, uint8_t *buf);
                         
                         ssize_t mqtt_unpack_pubxxx_response(struct mqtt_response *mqtt_response, uint8_t *buf);
                         
                         ssize_t mqtt_unpack_suback_response(struct mqtt_response *mqtt_response, uint8_t *buf);
                         
                         ssize_t mqtt_unpack_unsuback_response(struct mqtt_response *mqtt_response, uint8_t *buf);
                         
                         ssize_t mqtt_unpack_response(struct mqtt_response *response, uint8_t *buf, size_t bufsz);
                         
                         ssize_t mqtt_pack_fixed_header(uint8_t *buf, size_t bufsz, struct mqtt_fixed_header *fixed_header);
                         
                         enum MQTTConnectFlags {MQTT_CONNECT_RESERVED = 
                         1u, MQTT_CONNECT_CLEAN_SESSION = 
                         2u, MQTT_CONNECT_WILL_FLAG = 
                         4u, MQTT_CONNECT_WILL_QOS_0 = 
                         (0u & 0x03) << 3, MQTT_CONNECT_WILL_QOS_1 = 
                         (1u & 0x03) << 3, MQTT_CONNECT_WILL_QOS_2 = 
                         (2u & 0x03) << 3, MQTT_CONNECT_WILL_RETAIN = 
                         32u, MQTT_CONNECT_PASSWORD = 
                         64u, MQTT_CONNECT_USER_NAME = 
                         128u};
                         
                         ssize_t mqtt_pack_connection_request(uint8_t *buf, size_t bufsz, 
                         char *client_id, 
                         char *will_topic, 
                         void *will_message, 
                         size_t will_message_size, 
                         char *user_name, 
                         char *password, 
                         uint8_t connect_flags, 
                         uint16_t keep_alive);
                         
                         enum MQTTPublishFlags {MQTT_PUBLISH_DUP = 
                         8u, MQTT_PUBLISH_QOS_0 = 
                         (0u << 1) & 0x06, MQTT_PUBLISH_QOS_1 = 
                         (1u << 1) & 0x06, MQTT_PUBLISH_QOS_2 = 
                         (2u << 1) & 0x06, MQTT_PUBLISH_QOS_MASK = 
                         (3u << 1) & 0x06, MQTT_PUBLISH_RETAIN = 
                         0x01};
                         
                         ssize_t mqtt_pack_publish_request(uint8_t *buf, size_t bufsz, 
                         char *topic_name, 
                         uint16_t packet_id, 
                         void *application_message, 
                         size_t application_message_size, 
                         uint8_t publish_flags);
                         
                         ssize_t mqtt_pack_pubxxx_request(uint8_t *buf, size_t bufsz, 
                         enum MQTTControlPacketType control_type, 
                         uint16_t packet_id);
                         
                         ssize_t mqtt_pack_subscribe_request(uint8_t *buf, size_t bufsz, 
                         unsigned int packet_id, 
                         ...);
                         
                         ssize_t mqtt_pack_unsubscribe_request(uint8_t *buf, size_t bufsz, 
                         unsigned int packet_id, 
                         ...);
                         
                         ssize_t mqtt_pack_ping_request(uint8_t *buf, size_t bufsz);
                         
                         ssize_t mqtt_pack_disconnect(uint8_t *buf, size_t bufsz);
                         
                         enum MQTTQueuedMessageState {MQTT_QUEUED_UNSENT, MQTT_QUEUED_AWAITING_ACK, MQTT_QUEUED_COMPLETE};
                         
                         struct mqtt_queued_message
                         {
                                   
                                   uint8_t *start;
                                   
                                   size_t size;
                                   
                                   enum MQTTQueuedMessageState state;
                                   
                                   mqtt_pal_time_t time_sent;
                                   
                                   enum MQTTControlPacketType control_type;
                                   
                                   uint16_t packet_id;
                         };
                         
                         struct mqtt_message_queue
                         {
                                   
                                   void *mem_start;
                                   
                                   void *mem_end;
                                   
                                   uint8_t *curr;
                                   
                                   size_t curr_sz;
                                   
                                   struct mqtt_queued_message *queue_tail;
                         };
                         
                         void mqtt_mq_init(struct mqtt_message_queue *mq, void *buf, size_t bufsz);
                         
                         void mqtt_mq_clean(struct mqtt_message_queue *mq);
                         
                         struct mqtt_queued_message *mqtt_mq_register(struct mqtt_message_queue *mq, size_t nbytes);
                         
                         struct mqtt_queued_message *mqtt_mq_find(struct mqtt_message_queue *mq, enum MQTTControlPacketType control_type, uint16_t *packet_id);
                         
                         struct mqtt_client
                         {
                                   
                                   mqtt_pal_socket_handle socketfd;
                                   
                                   uint16_t pid_lfsr;
                                   
                                   uint16_t keep_alive;
                                   
                                   int number_of_keep_alives;
                                   
                                   size_t send_offset;
                                   
                                   mqtt_pal_time_t time_of_last_send;
                                   
                                   enum MQTTErrors error;
                                   
                                   int response_timeout;
                                   
                                   int number_of_timeouts;
                                   
                                   float typical_response_time;
                                   
                                   void (*publish_response_callback)(void **state, struct mqtt_response_publish *publish);
                                   
                                   void *publish_response_callback_state;
                                   
                                   enum MQTTErrors (*inspector_callback)(struct mqtt_client *);
                                   
                                   void (*reconnect_callback)(struct mqtt_client *, void **);
                                   
                                   void *reconnect_state;
                                   
                                   
                                   struct anonstruct_1
                                   {
                                             
                                             uint8_t *mem_start;
                                             
                                             size_t mem_size;
                                             
                                             uint8_t *curr;
                                             
                                             size_t curr_sz;
                                   } recv_buffer;
                                   
                                   mqtt_pal_mutex_t mutex;
                                   
                                   struct mqtt_message_queue mq;
                         };
                         
                         uint16_t __mqtt_next_pid(struct mqtt_client *client);
                         
                         ssize_t __mqtt_send(struct mqtt_client *client);
                         
                         ssize_t __mqtt_recv(struct mqtt_client *client);
                         
                         enum MQTTErrors mqtt_sync(struct mqtt_client *client);
                         
                         enum MQTTErrors mqtt_init(struct mqtt_client *client, 
                         mqtt_pal_socket_handle sockfd, 
                         uint8_t *sendbuf, size_t sendbufsz, 
                         uint8_t *recvbuf, size_t recvbufsz, 
                         void (*publish_response_callback)(void **state, struct mqtt_response_publish *publish));
                         
                         void mqtt_init_reconnect(struct mqtt_client *client, 
                         void (*reconnect_callback)(struct mqtt_client *client, void **state), 
                         void *reconnect_state, 
                         void (*publish_response_callback)(void **state, struct mqtt_response_publish *publish));
                         
                         void mqtt_reinit(struct mqtt_client *client, 
                         mqtt_pal_socket_handle socketfd, 
                         uint8_t *sendbuf, size_t sendbufsz, 
                         uint8_t *recvbuf, size_t recvbufsz);
                         
                         enum MQTTErrors mqtt_connect(struct mqtt_client *client, 
                         char *client_id, 
                         char *will_topic, 
                         void *will_message, 
                         size_t will_message_size, 
                         char *user_name, 
                         char *password, 
                         uint8_t connect_flags, 
                         uint16_t keep_alive);
                         
                         enum MQTTErrors mqtt_publish(struct mqtt_client *client, 
                         char *topic_name, 
                         void *application_message, 
                         size_t application_message_size, 
                         uint8_t publish_flags);
                         
                         ssize_t __mqtt_puback(struct mqtt_client *client, uint16_t packet_id);
                         
                         ssize_t __mqtt_pubrec(struct mqtt_client *client, uint16_t packet_id);
                         
                         ssize_t __mqtt_pubrel(struct mqtt_client *client, uint16_t packet_id);
                         
                         ssize_t __mqtt_pubcomp(struct mqtt_client *client, uint16_t packet_id);
                         
                         enum MQTTErrors mqtt_subscribe(struct mqtt_client *client, 
                         char *topic_name, 
                         int max_qos_level);
                         
                         enum MQTTErrors mqtt_unsubscribe(struct mqtt_client *client, 
                         char *topic_name);
                         
                         enum MQTTErrors mqtt_ping(struct mqtt_client *client);
                         
                         enum MQTTErrors __mqtt_ping(struct mqtt_client *client);
                         
                         enum MQTTErrors mqtt_disconnect(struct mqtt_client *client);
                         
                         enum MQTTErrors mqtt_reconnect(struct mqtt_client *client);
                         
                         void *init_thread_0(void *arg);
                         
                         void *connect_thread_0(void *arg);
                         
                         void *subscribe_thread_0(void *arg);
                         
                         void *publish_thread_0(void *arg);
                         
                         void *disconnect_thread_0(void *arg);
                         
                         cspthread_mutex_t lock = (PTHREAD_MUTEX_INITIALIZER);
                         
                         struct mqtt_client client;
                         
                         int main_thread(void)
                         
                         {
                                   
IF(0,0,tmain_1)
                                   
                                   static cspthread_t *__cs_local_main_threads;
                                   __cs_local_main_threads = ((cspthread_t *) malloc((sizeof(cspthread_t)) * 5));
                                   
                                   pthread_create_2(& __cs_local_main_threads[0], 0, init_thread_0, 0, 1);
                                   
tmain_1: IF(0,1,tmain_2)
                                   
                                   pthread_create_2(& __cs_local_main_threads[1], 0, connect_thread_0, 0, 2);
                                   
tmain_2: IF(0,2,tmain_3)
                                   
                                   pthread_create_2(& __cs_local_main_threads[2], 0, subscribe_thread_0, 0, 3);
                                   
tmain_3: IF(0,3,tmain_4)
                                   
                                   pthread_create_2(& __cs_local_main_threads[3], 0, publish_thread_0, 0, 4);
                                   
tmain_4: IF(0,4,tmain_5)
                                   
                                   pthread_create_2(& __cs_local_main_threads[4], 0, disconnect_thread_0, 0, 5);
                         
                                             {
                                             
                                             static int __cs_local_main_i;
                                             
                                             __cs_local_main_i = (0);
                         
                                                                 {
                                                       
tmain_5: IF(0,5,tmain_6)
                                                       
                                                       pthread_join(__cs_local_main_threads[__cs_local_main_i], 0);
                                             }
                                             
                                             ;
                                             
                                             ++ __cs_local_main_i;
                                             
tmain_6: IF(0,6,tmain_7)
                                             
                                             __CPROVER_assume(! (__cs_local_main_i < 5));
                                             
                                             __exit_loop_1:
                                             __CPROVER_assume(__cs_pc_cs[0] >= 7);
                         
                                             
                                             ;
                                             ;
                                   }
                                   
                                   ;
                                   
                                   goto __exit_main;
                                   ;
                                   
                                   __exit_main:
                                   __CPROVER_assume(__cs_pc_cs[0] >= 7);
                         
                                   
                                   ;
                                   ;
                                   
tmain_7: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         void *init_thread_0(void *__cs_param_init_thread_arg)
                         
                         {
                                   
IF(1,0,tinit_thread_0_1)
                                   
                                   static uint8_t *__cs_local_init_thread_sendbuf;
                                   __cs_local_init_thread_sendbuf = ((uint8_t *) malloc((sizeof(uint8_t)) * 2048));
                                   
                                   static uint8_t *__cs_local_init_thread_recvbuf;
                                   __cs_local_init_thread_recvbuf = ((uint8_t *) malloc((sizeof(uint8_t)) * 1024));
                                   
tinit_thread_0_1: IF(1,1,tinit_thread_0_2)
                                   
                                   mqtt_init(& client, 0, __cs_local_init_thread_sendbuf, sizeof(__cs_local_init_thread_sendbuf), __cs_local_init_thread_recvbuf, sizeof(__cs_local_init_thread_recvbuf), 0);
                                   
tinit_thread_0_2: IF(1,2,tinit_thread_0_3)
                                   
                                   pthread_mutex_lock(& lock);
                                   
tinit_thread_0_3: IF(1,3,tinit_thread_0_4)
                                   
                                   mqtt_connect(& client, "mqtt_client_id", 0, 0, 0, "username", "password", 1, 60);
                                   
tinit_thread_0_4: IF(1,4,tinit_thread_0_5)
                                   
                                   pthread_mutex_unlock(& lock);
                                   
tinit_thread_0_5: IF(1,5,tinit_thread_0_6)
                                   
                                   mqtt_sync(& client);
                                   
                                   goto __exit_init_thread;
                                   ;
                                   
                                   __exit_init_thread:
                                   __CPROVER_assume(__cs_pc_cs[1] >= 6);
                         
                                   
                                   ;
                                   ;
                                   
tinit_thread_0_6: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         void *connect_thread_0(void *__cs_param_connect_thread_arg)
                         
                         {
                                   
IF(2,0,tconnect_thread_0_1)
                                   
                                   static int __cs_local_connect_thread_rc;
                                   __cs_local_connect_thread_rc = (mqtt_pal_connect(& client, "localhost", 1883, 0));
                                   
                                   static _Bool __cs_local_connect_thread___cs_tmp_if_cond_0;
                                   
                                   __cs_local_connect_thread___cs_tmp_if_cond_0 = (__cs_local_connect_thread_rc != MQTT_OK);
                                   
                                   if (__cs_local_connect_thread___cs_tmp_if_cond_0)
                         
                                             {
                                             
                                             printf("Error: mqtt_pal_connect failed (error code: %d)\n", __cs_local_connect_thread_rc);
                                             
                                             goto __exit_connect_thread;
                                             ;
                                   }
                         
                                   
                                   ;
                                   
tconnect_thread_0_1: IF(2,1,tconnect_thread_0_2)
                                   
                                   mqtt_sync(& client);
                                   
                                   goto __exit_connect_thread;
                                   ;
                                   
                                   __exit_connect_thread:
                                   __CPROVER_assume(__cs_pc_cs[2] >= 2);
                         
                                   
                                   ;
                                   ;
                                   
tconnect_thread_0_2: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         void *subscribe_thread_0(void *__cs_param_subscribe_thread_arg)
                         
                         {
                                   
IF(3,0,tsubscribe_thread_0_1)
                                   
                                   pthread_mutex_lock(& lock);
                                   
tsubscribe_thread_0_1: IF(3,1,tsubscribe_thread_0_2)
                                   
                                   static int __cs_local_subscribe_thread_rc;
                                   __cs_local_subscribe_thread_rc = (mqtt_subscribe(& client, "example/topic", 0));
                                   
tsubscribe_thread_0_2: IF(3,2,tsubscribe_thread_0_3)
                                   
                                   pthread_mutex_unlock(& lock);
                                   
                                   static _Bool __cs_local_subscribe_thread___cs_tmp_if_cond_1;
                                   
                                   __cs_local_subscribe_thread___cs_tmp_if_cond_1 = (__cs_local_subscribe_thread_rc != MQTT_OK);
                                   
                                   if (__cs_local_subscribe_thread___cs_tmp_if_cond_1)
                         
                                             {
                                             
                                             printf("Error: mqtt_subscribe failed (error code: %d)\n", __cs_local_subscribe_thread_rc);
                                             
                                             goto __exit_subscribe_thread;
                                             ;
                                   }
                         
                                   
                                   ;
                                   
tsubscribe_thread_0_3: IF(3,3,tsubscribe_thread_0_4)
                                   
                                   mqtt_sync(& client);
                                   
                                   goto __exit_subscribe_thread;
                                   ;
                                   
                                   __exit_subscribe_thread:
                                   __CPROVER_assume(__cs_pc_cs[3] >= 4);
                         
                                   
                                   ;
                                   ;
                                   
tsubscribe_thread_0_4: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         void *publish_thread_0(void *__cs_param_publish_thread_arg)
                         
                         {
                                   
IF(4,0,tpublish_thread_0_1)
                                   
                                   static char *__cs_local_publish_thread_message;
                                   __cs_local_publish_thread_message = ("Hello, MQTT!");
                                   
tpublish_thread_0_1: IF(4,1,tpublish_thread_0_2)
                                   
                                   pthread_mutex_lock(& lock);
                                   
tpublish_thread_0_2: IF(4,2,tpublish_thread_0_3)
                                   
                                   static int __cs_local_publish_thread_rc;
                                   __cs_local_publish_thread_rc = (mqtt_publish(& client, "example/topic", __cs_local_publish_thread_message, strlen(__cs_local_publish_thread_message), MQTT_PUBLISH_QOS_0));
                                   
tpublish_thread_0_3: IF(4,3,tpublish_thread_0_4)
                                   
                                   pthread_mutex_unlock(& lock);
                                   
                                   static _Bool __cs_local_publish_thread___cs_tmp_if_cond_2;
                                   
                                   __cs_local_publish_thread___cs_tmp_if_cond_2 = (__cs_local_publish_thread_rc != MQTT_OK);
                                   
                                   if (__cs_local_publish_thread___cs_tmp_if_cond_2)
                         
                                             {
                                             
                                             printf("Error: mqtt_publish failed (error code: %d)\n", __cs_local_publish_thread_rc);
                                             
                                             goto __exit_publish_thread;
                                             ;
                                   }
                         
                                   
                                   ;
                                   
tpublish_thread_0_4: IF(4,4,tpublish_thread_0_5)
                                   
                                   mqtt_sync(& client);
                                   
                                   goto __exit_publish_thread;
                                   ;
                                   
                                   __exit_publish_thread:
                                   __CPROVER_assume(__cs_pc_cs[4] >= 5);
                         
                                   
                                   ;
                                   ;
                                   
tpublish_thread_0_5: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         void *disconnect_thread_0(void *__cs_param_disconnect_thread_arg)
                         
                         {
                                   
IF(5,0,tdisconnect_thread_0_1)
                                   
                                   pthread_mutex_lock(& lock);
                                   
tdisconnect_thread_0_1: IF(5,1,tdisconnect_thread_0_2)
                                   
                                   static int __cs_local_disconnect_thread_rc;
                                   __cs_local_disconnect_thread_rc = (mqtt_disconnect(& client));
                                   
tdisconnect_thread_0_2: IF(5,2,tdisconnect_thread_0_3)
                                   
                                   pthread_mutex_unlock(& lock);
                                   
                                   static _Bool __cs_local_disconnect_thread___cs_tmp_if_cond_3;
                                   
                                   __cs_local_disconnect_thread___cs_tmp_if_cond_3 = (__cs_local_disconnect_thread_rc != MQTT_OK);
                                   
                                   if (__cs_local_disconnect_thread___cs_tmp_if_cond_3)
                         
                                             {
                                             
                                             printf("Error: mqtt_disconnect failed (error code: %d)\n", __cs_local_disconnect_thread_rc);
                                             
                                             goto __exit_disconnect_thread;
                                             ;
                                   }
                         
                                   
                                   ;
                                   
tdisconnect_thread_0_3: IF(5,3,tdisconnect_thread_0_4)
                                   
                                   mqtt_sync(& client);
                                   
                                   goto __exit_disconnect_thread;
                                   ;
                                   
                                   __exit_disconnect_thread:
                                   __CPROVER_assume(__cs_pc_cs[5] >= 4);
                         
                                   
                                   ;
                                   ;
                                   
tdisconnect_thread_0_4: 
                                   
                                   pthread_exit(0);
                         }
                         
                         
                         int main(void)
                         {
                                   
/* round  0 */
                                   
/* main */
                                   
                                   __cs_thread_index = (0);
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t0_r0;
                                   
                                   __cs_pc_cs[0] = (__cs_tmp_t0_r0);
                                   
                                   __CPROVER_assume(__cs_pc_cs[0] > 0);
                                   
                                   __CPROVER_assume(__cs_pc_cs[0] <= 7);
                                   
                                   main_thread();
                                   
                                   __cs_pc[0] = (__cs_pc_cs[0]);
                                   
/* init_thread_0 */
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t1_r0;
                                   
                                   if (__cs_active_thread[1])
                                   {
                                             
                                             __cs_thread_index = (1);
                                             
                                             __cs_pc_cs[1] = (__cs_tmp_t1_r0);
                                             
                                             __CPROVER_assume(__cs_pc_cs[1] <= 6);
                                             
                                             init_thread_0(__cs_threadargs[1]);
                                             
                                             __cs_pc[1] = (__cs_pc_cs[1]);
                                   }
                         
                                   
/* connect_thread_0 */
                                   
                                   unsigned __CPROVER_bitvector[2] __cs_tmp_t2_r0;
                                   
                                   if (__cs_active_thread[2])
                                   {
                                             
                                             __cs_thread_index = (2);
                                             
                                             __cs_pc_cs[2] = (__cs_tmp_t2_r0);
                                             
                                             __CPROVER_assume(__cs_pc_cs[2] <= 2);
                                             
                                             connect_thread_0(__cs_threadargs[2]);
                                             
                                             __cs_pc[2] = (__cs_pc_cs[2]);
                                   }
                         
                                   
/* subscribe_thread_0 */
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t3_r0;
                                   
                                   if (__cs_active_thread[3])
                                   {
                                             
                                             __cs_thread_index = (3);
                                             
                                             __cs_pc_cs[3] = (__cs_tmp_t3_r0);
                                             
                                             __CPROVER_assume(__cs_pc_cs[3] <= 4);
                                             
                                             subscribe_thread_0(__cs_threadargs[3]);
                                             
                                             __cs_pc[3] = (__cs_pc_cs[3]);
                                   }
                         
                                   
/* publish_thread_0 */
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t4_r0;
                                   
                                   if (__cs_active_thread[4])
                                   {
                                             
                                             __cs_thread_index = (4);
                                             
                                             __cs_pc_cs[4] = (__cs_tmp_t4_r0);
                                             
                                             __CPROVER_assume(__cs_pc_cs[4] <= 5);
                                             
                                             publish_thread_0(__cs_threadargs[4]);
                                             
                                             __cs_pc[4] = (__cs_pc_cs[4]);
                                   }
                         
                                   
/* disconnect_thread_0 */
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t5_r0;
                                   
                                   if (__cs_active_thread[5])
                                   {
                                             
                                             __cs_thread_index = (5);
                                             
                                             __cs_pc_cs[5] = (__cs_tmp_t5_r0);
                                             
                                             __CPROVER_assume(__cs_pc_cs[5] <= 4);
                                             
                                             disconnect_thread_0(__cs_threadargs[5]);
                                             
                                             __cs_pc[5] = (__cs_pc_cs[5]);
                                   }
                         
                                   
                                   unsigned __CPROVER_bitvector[3] __cs_tmp_t0_r1;
                                   
                                   if (__cs_active_thread[0])
                                   {
                                             
                                             __cs_thread_index = (0);
                                             
                                             __cs_pc_cs[0] = (__cs_tmp_t0_r1);
                                             
                                             __CPROVER_assume(__cs_pc_cs[0] >= __cs_pc[0]);
                                             
                                             __CPROVER_assume(__cs_pc_cs[0] <= 7);
                                             
                                             main_thread();
                                   }
                         
                                   
                                   return (0);
                         }
                         
                         
